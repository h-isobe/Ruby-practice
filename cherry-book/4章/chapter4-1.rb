###配列についてもっと詳しく

##要素の取得方法

#添字を使うと、添字の位置と取得する長さを指定できる
a = [1,2,3,4,5]
a[1,3] #=> [2,3,4]

#value_atメソッドで、取得したい要素の添字を複数指定できる
a = [1,2,3,4,5]
a.values_at(0, 2, 4) #=> [1, 3, 5]

#負の値を使って取得
a = [1,2,3]
a[-1] #=> 3
a[-2] #=> 2

#lastメソッド
a = [1,2,3]
a.last    #=> 3
#引数に0以上を渡すと配列として取得
a.last(2) #=> [2, 3]

#firstメソッド
a = [1,2,3]
a.first #=> 1
#引数に0以上を渡すと配列として取得
a.first(2) #=> [1, 2]


##要素の変更方法

a = [1,2,3]
a[-3] = -10 #=> [-10,2,3]

#指定可能な負の値よりも小さくなるとエラーが発生する
a[-4] = 0 #=>  IndexError (index -4 too small for array; minimum: -3)

a = [1,2,3,4,5]
#2つめから3要素分を100に置き換える
a[1, 3] = 100
a #=> [1, 100, 5]

#pushメソッドで要素を追加できる。pushメソッドは複数の値を追加できる
a = []
a.push(1)    #=> [1]
a.push(2, 3) #=> [1, 2, 3]

#deleteメソッドで指定した値に一致する要素を削除できる
a [1,2,3,1,2,3]
a.delete(2) #=> 2
a           #=> [1, 3, 1, 3]

#存在しない値を指定するとnilが返る
a.delete(5) #=> nil
a           #=> [1, 3, 1, 3]


##配列の連結

a = [1]
b = [2,3]
a.concat(b) #=> [1, 2, 3]
# aは連結される(破壊的)
a #=> [1, 2, 3]

a = [1]
b = [2,3]
a + b #=> [1, 2, 3]
# aもbも変更されない
a #=> [1]
b #=> [2, 3]

#破壊的な変更は思いがけない悪影響を与える場合があるため、基本的には+を使う


##メソッドの可変長引数(個数に制限のない引数のこと。手前に*をつける)
def  greeting(*names)
  "#{names.join('と')}、こんにちは！"
end
greeting('田中さん')                         #=> "田中さん、こんにちは！"
greeting('田中さん', '鈴木さん')             #=> "田中さんと鈴木さん、こんにちは！"
greeting('田中さん', '鈴木さん', '佐藤さん') #=> "田中さんと鈴木さんと佐藤さん、こんにちは！"


##配列に初期値を設定する場合の注意点

#要素が5つで'default'を初期値とする配列を作成する
a = Array.new(5, 'dafault')
a #=> ["dafault", "dafault", "dafault", "dafault", "dafault"]

# 1番目の要素を取得する
str = a[0]
str #=> 'dafault'

# 1番目の要素を大文字に変換する(破壊的変更)
str.upcase!
str #=> "DAFAULT"

# 配列の要素すべてが大文字に変わってしまう
a #=> ["DAFAULT", "DAFAULT", "DAFAULT", "DAFAULT", "DAFAULT"]

# 上記問題を避けるために引数でなく、ブロックで初期値を渡す
# ブロックを使って、ブロックの戻り値を初期値とする
# (ブロック引数には添字が渡されるが、ここでは使わないのでブロック引数を省略)
a = Array.new(5) {'dafault'}
a #=> ["dafault", "dafault", "dafault", "dafault", "dafault"]

# 1番目の要素を取得する
str = a[0]
str #=> "dafault"

# 1番目の要素を大文字に変換する(破壊的変更)
str.upcase!
str #=> "DAFAULT"

# 1番目の要素だけが大文字になり、他は変わらない
a #=> ["DAFAULT", "dafault", "dafault", "dafault", "dafault"]
